
### CONFIG ###

POINTS <- read.csv('points.csv', header = FALSE)
POINTS@names <- c('No', 'X coord', 'Y coord')

ROUTES <- read.csv('routes.csv')

P_NOF_POINTS <- nrow(POINTS)
P_NOF_CORES <- 80
P_NOF_RUNS <- 10000
P_NOF_GENERATIONS <- 10000
P_NOF_GENERATIONS_TO_RETRY <- 250
P_GENERATION_SIZE <- 1000
P_NOF_INSTANCES_TO_KEEP <- 50
P_NOF_INSTANCES_TO_GENERATE <- 50
P_NOF_MUTATIONS_TO_GENERATE <- 450
P_NOF_COMBINATIONS_TO_GENERATE <- 450

DISTANCES <- matrix(nrow = P_NOF_POINTS, ncol = P_NOF_POINTS)
for (I in 1:(P_NOF_POINTS - 1))
	for (J in (I + 1):P_NOF_POINTS) {
		DIST_X <- POINTS[I, 2] - POINTS[J, 2]
		DIST_Y <- POINTS[I, 3] - POINTS[J, 3]
		DISTANCES[I, J] <- sqrt(DIST_X * DIST_X + DIST_Y * DIST_Y)
	}

### FUNCTIONS ###

CALCULATE_DISTANCE <- function(ROUTE) {

	DISTANCE <- 0
	for (I in 1:P_NOF_POINTS) {
		POINT_1 <- if (I == 1) ROUTE[P_NOF_POINTS] else ROUTE[I - 1]
		POINT_2 <- ROUTE[I]
		DISTANCE <- DISTANCE + DISTANCES[min(POINT_1, POINT_2), max(POINT_1, POINT_2)]
	}

	DISTANCE
}

GENERATE_ROUTE <- function() {

	ROUTE <- sample(1:P_NOF_POINTS, P_NOF_POINTS)
	ROUTE[P_NOF_POINTS + 1] <- CALCULATE_DISTANCE(ROUTE)
	ROUTE
}

MUTATE_ROUTE <- function(ROUTE) {

	NOF_CHANGES <- sample(1:7, 1)
	POSITIONS <- sample(1:P_NOF_POINTS, NOF_CHANGES * 2)
	for (I in 1:NOF_CHANGES) {
		TMP <- ROUTE[POSITIONS[I * 2 - 1]]
		ROUTE[POSITIONS[I * 2 - 1]] <- ROUTE[POSITIONS[I * 2]]
		ROUTE[POSITIONS[I * 2]] <- TMP
	}

	ROUTE[P_NOF_POINTS + 1] <- CALCULATE_DISTANCE(ROUTE)
	ROUTE
}

COMBINE_ROUTES <- function(PARENT_1, PARENT_2) {

	POSITIONS <- sample(1:(P_NOF_POINTS - 1), 2)
	POSITION_1 <- min(POSITIONS)
	POSITION_2 <- max(POSITIONS)

	RANGE_1 <- 1:POSITION_1
	RANGE_2 <- (POSITION_1 + 1):POSITION_2
	RANGE_3 <- (POSITION_2 + 1):P_NOF_POINTS

	CHILD_1 <- c(PARENT_1[RANGE_1], PARENT_2[RANGE_2], PARENT_1[RANGE_3])
	CHILD_2 <- c(PARENT_2[RANGE_1], PARENT_1[RANGE_2], PARENT_2[RANGE_3])

	while (TRUE) {

		DUPLICATES_1 <- which(CHILD_1 %in% CHILD_1[duplicated(CHILD_1)])
		if (length(DUPLICATES_1) == 0)
			break;

		for (I in DUPLICATES_1[DUPLICATES_1 %in% c(RANGE_1, RANGE_3)]) {
			J <- which(CHILD_1 == CHILD_1[I])
			J <- J[J %in% RANGE_2]
			CHILD_1[I] <- CHILD_2[J]
		}
	}

	CHILD_1[P_NOF_POINTS + 1] <- CALCULATE_DISTANCE(CHILD_1)
	CHILD_1
}

PLOT_ROUTE <- function(ROUTE) {

	plot.new()
	plot.window(c(0, 1), c(0, 1))
	polypath(POINTS[ROUTE[1:P_NOF_POINTS], 2], POINTS[ROUTE[1:P_NOF_POINTS], 3])
}

### PARALLEL GENERATION ###

library(doParallel)

registerDoParallel(cores = P_NOF_CORES)
CL <- makeCluster(P_NOF_CORES)

RESULTS <- foreach(RUN = 1:P_NOF_RUNS, .combine = rbind) %dopar% {

	#PLOT_ROUTE(1:P_NOF_POINTS)

	GENERATION <- data.matrix(ROUTES) #matrix(nrow = P_GENERATION_SIZE, ncol = P_NOF_POINTS + 1)
	MIN_DISTANCE <- Inf
	MIN_DISTANCE_COUNT <- 0
	#for (I in 1:P_GENERATION_SIZE)
	#GENERATION[I,] <- GENERATE_ROUTE()

	for (I in 1:P_NOF_GENERATIONS) {
		ORDER <- order(GENERATION[, P_NOF_POINTS + 1])
		GENERATION <- GENERATION[ORDER,]
		GENERATION_NEW <- matrix(nrow = P_GENERATION_SIZE, ncol = P_NOF_POINTS + 1)

		if (MIN_DISTANCE > GENERATION[1, P_NOF_POINTS + 1]) {
			MIN_DISTANCE <- GENERATION[1, P_NOF_POINTS + 1]
			MIN_DISTANCE_COUNT <- 0
			#PLOT_ROUTE(GENERATION[1,])

		} else
			MIN_DISTANCE_COUNT <- MIN_DISTANCE_COUNT + 1

		if (MIN_DISTANCE_COUNT >= P_NOF_GENERATIONS_TO_RETRY)
			break;

		for (J in 1:P_NOF_INSTANCES_TO_KEEP)
			GENERATION_NEW[J,] <- GENERATION[J,]

		for (J in 1:P_NOF_INSTANCES_TO_GENERATE) {
			K <- P_NOF_INSTANCES_TO_KEEP + J
			GENERATION_NEW[K,] <- GENERATE_ROUTE()
		}

		ORIGIN_INDEXES <- sample(1:nrow(GENERATION), P_NOF_MUTATIONS_TO_GENERATE, replace = TRUE)
		for (J in 1:P_NOF_MUTATIONS_TO_GENERATE) {
			K <- P_NOF_INSTANCES_TO_KEEP + P_NOF_INSTANCES_TO_GENERATE + J
			GENERATION_NEW[K,] <- MUTATE_ROUTE(GENERATION[ORIGIN_INDEXES[J],])
		}

		ORIGIN_INDEXES <- sample(1:nrow(GENERATION), P_NOF_COMBINATIONS_TO_GENERATE * 2, replace = TRUE)
		for (J in 1:P_NOF_COMBINATIONS_TO_GENERATE) {
			K <- P_NOF_INSTANCES_TO_KEEP + P_NOF_INSTANCES_TO_GENERATE + P_NOF_MUTATIONS_TO_GENERATE + J
			PARENT_1 <- GENERATION[ORIGIN_INDEXES[J * 2 - 1],]
			PARENT_2 <- GENERATION[ORIGIN_INDEXES[J * 2],]
			GENERATION_NEW[K,] <- COMBINE_ROUTES(PARENT_1, PARENT_2)
		}

		GENERATION <- GENERATION_NEW
	}

	write(paste(GENERATION[1,], collapse = ','), 'routes.csv', append = TRUE)
	GENERATION[1,]
}

stopCluster(CL)

### FIX PRECISION ###

ROUTES_MATRIX <- data.matrix(ROUTES)
for (I in 1:nrow(ROUTES_MATRIX)) {
	ROUTES_MATRIX[I, P_NOF_POINTS + 1] <- CALCULATE_DISTANCE(ROUTES_MATRIX[I,])
	write(paste(ROUTES_MATRIX[I,], collapse = ','), 'routes.csv', append = TRUE)
}

### PLOTTING ###

for (I in 1:min(5, nrow(ROUTES)))
	PLOT_ROUTE(t(ROUTES[I, 1:P_NOF_POINTS]))
